#! /usr/bin/perl
eval (our $script = sprintf qq{#line %d "%s"\n%s;1}, __LINE__ + 1, __FILE__, <<'__END__') or die $@;
use strict;
my $SSH = 'ssh';
my $PERL = '/usr/bin/perl';
my $SYSFS = '/sys';
my $drivers = "$SYSFS/bus/usb/drivers";
my $devices = "$SYSFS/bus/usb/devices";
my $verbose;
eval qq{\$$1="\Q$2\E";shift} or die $@ while $ARGV[0] =~ /^(\w+)=(.*)/s;
use constant {
	LOG_WARNING => 4, LOG_ERR => 3, LOG_INFO => 6, LOG_DEBUG => 7,
	LOG_DAEMON => 3<<3,
};
my $logger = sub { shift; print STDERR @_ };
sub DEBUG {} *DEBUG = sub { $logger->(LOG_DEBUG, @_) } if $verbose;
$SIG{__DIE__} = sub { die @_ if $^S; $logger->(LOG_ERR, "ERROR: @_"); exit 1 };
$SIG{__WARN__} = sub { $logger->(LOG_WARNING, "WARNING: @_") };
my $op = shift;
if($op eq 'remote'){
	remote_script(@ARGV);
}elsif($op eq 'list'){
	list_devices(@ARGV);
}elsif($op eq 'find'){
	print find_dev(@ARGV), "\n";
}elsif($op eq 'unbind'){
	remote_detach(find_dev(@ARGV));
}elsif($op eq 'detach'){
	local_detach(@ARGV);
}elsif($op eq 'keep'){
	persistent(@ARGV);
}elsif($op eq 'daemon'){
	daemon(@ARGV); 
}elsif(length $op){
	exit xwait(local_script($op, @ARGV));
}else{
	my $cmd = $0 =~ s{^.*/}{}r;
	exit print <<"EOT";
usage:
	$cmd USER\@HOST DEV_PATTERN
		attach single device matching DEV_PATTERN from HOST

	$cmd USER\@HOST [list]
		list devices from HOST

	$cmd USER\@HOST find DEV_PATTERN
		find single device matching DEV_PATTERN on HOST

	$cmd keep USER\@HOST ...
		same commands as above, but keep trying to connect to HOST
		and to reconnect to it if the connection is broken

	$cmd daemon USER\@HOST ...
		same as 'keep' but detached from the tty and using syslog
		for messages and errors

	$cmd list
	$cmd find DEV_PATTERN
		same commands as above on the local machine

DEV_PATTERN is as returned by the 'list' command: a busid like 3-3.1, a
vip:pid like 03f0:e111, or a pattern matching the vid:pid, the product name
or the serial number.

You can add command line options for ssh before USER\@HOST.
EOT
}

###############################################

sub readfile { open my $h, shift or return ""; local $/; <$h> =~ s/\s+$//r }
sub deb { DEBUG "@_\n" }
sub xwritefile {
	my $f = shift;
	deb "WRITE $f < @_";
	open my $h, '>', $f or die "open> $f: $!\n";
	syswrite $h, "@_" or die "write> $f @_: $!\n";
}
sub xreadfile {
	my $f = shift;
	open my $h, '<', $f or die "open< $f: $!\n";
	local $/; my $d = <$h> or die "readline< $f: $!\n";
	$d =~ s/\s+$//;
	die "\nempty file $f" unless length $d;
	deb "READ $f > $d";
	$d;
}
sub xsystem {
	deb "EXEC @_";
	system(@_) == -1 and die "system $_[0]: $!";
	die "system @_: status ".($? >> 8) if $?;
}
sub xtmpdir {
	require File::Temp;
	File::Temp->newdir("usbip-ssh-XXXXXX", TMPDIR => 1);
}

###############################################

use constant {
	LOW => 1, FULL => 2, HIGH => 3, SUPER => 5, SUPER_PLUS => 6,
	SDEV_ST_AVAILABLE => 1, SDEV_ST_USED => 2,
	VDEV_ST_NULL => 4, VDEV_ST_USED => 6,
};
sub remote_attach {
	my ($sockfd, $busid) = @_;
	die "$busid is a hub, and usbip-host cannot attach to a hub\n"
		if readfile("$devices/$busid/bDeviceClass") eq '09';
	xsystem qw(/sbin/modprobe -v usbip-host)
		unless -d "$drivers/usbip-host";
	my $status = readfile "$drivers/usbip-host/$busid/usbip_status";
	if($status == SDEV_ST_USED){
		xwritefile "$devices/$busid/usbip_sockfd", -1;
	}elsif($status != SDEV_ST_AVAILABLE){
		xwritefile "$drivers/usb/unbind", $busid;
		xwritefile "$drivers/usbip-host/match_busid", "add $busid";
		xwritefile "$drivers/usbip-host/bind", $busid;
	}
	xwritefile "$devices/$busid/usbip_sockfd", $sockfd;
}
sub remote_detach {
	my $busid = shift;
	xwritefile "$drivers/usbip-host/unbind", $busid;
	xwritefile "$drivers/usbip-host/match_busid", "del $busid";
	xwritefile "$drivers/usbip-host/rebind", $busid;
}
sub local_attach {
	my ($sockfd, $bus, $dev, $speed) = @_;
	# as per linux/usb/ch9.h and drivers/usb/core/sysfs.c
	my %hspeed = ( 1.5 => LOW, 12 => FULL, 480 => HIGH,
		5000 => SUPER, 10000 => SUPER_PLUS, 20000 => SUPER_PLUS,
	);
	my $hspeed = $hspeed{$speed} // HIGH;
	my ($vhci, $port) = find_vhci_and_port($hspeed);
	xwritefile "$vhci/attach",
		sprintf "%d %d %d %d", $port, $sockfd, $bus<<16|$dev, $hspeed;
}
sub local_detach {
	my $busid = join '|', map { /^all$/i ? '.*' : quotemeta } @_;
	my (@b, $n);
	for my $f (<$SYSFS/devices/platform/vhci_hcd.*/status*>){
		open my $h, '<', $f or warn "open $f: $!" and next;
		<$h>; # skip header
		while(<$h>){
			my ($hub, $port, $sta, $spd, $dev, $sock_fd, $lbusid)
				= split;
			next unless $sta == VDEV_ST_USED;
			push @b, $lbusid;
			if($lbusid =~ $busid){
				my ($vhci) = $f =~ m{(.*)/};
				xwritefile "$vhci/detach", int($port);
				$n++;
			}
		}
	}
	die "no devices attached\n" unless @b;
	die "'@_' did not match any of: @b\n" unless $n;
}
###############################################
sub find_vhci_and_port {
	my $speed = shift;
	my $shub = $speed >= SUPER ? 'ss' : 'hs';
	xsystem qw(/sbin/modprobe -v vhci-hcd)
		unless <$SYSFS/devices/platform/vhci_hcd.*>;
	for my $f (<$SYSFS/devices/platform/vhci_hcd.*/status*>){
		open my $h, '<', $f or warn "open $f: $!" and next;
		<$h>; # skip header
		while(<$h>){
			my ($hub, $port, $sta) = split;
			return $f =~ m{^(.*)/}, int($port)
				if $sta == VDEV_ST_NULL and $hub eq $shub;
		}
	}
	die "no suitable vhci port found for speed = $speed";
}
sub find_dev {
	my ($pat) = @_;
	if($pat =~ /^\d+-\d+(?:\.\d+)*$/){
		return $pat if -d "$devices/$pat";
		die "no such device $pat";
	}
	for($pat){
		s/\b0*([0-9a-f]+)(?=:)|:\K0*([0-9a-f]+)\b/\\b0*\L$1$2\\b/gi;
		s/\s+/ */g;
		$_ = qr/$_/;
	}
	deb "looking for $pat inside $devices";
	my @found;
	for my $p (<$devices/[0-9]*>){
		next unless my ($busid) = $p =~ m{/(\d+-\d+(?:\.\d+)*)$};
		my ($vid, $pid, $serial, $manufacturer, $product) =
			map readfile("$p/$_"),
			qw(idVendor idProduct serial manufacturer product);
		my $spec = sprintf "%-10s %s:%s  %s  %s  %s",
			$busid, $vid, $pid, $serial, $manufacturer, $product;
		push @found, $busid if my $found = $spec =~ $pat;
		deb sprintf "  %2s %s", $found && "=>", $spec;
		
	}
	return $found[0] if @found == 1;
	die @found ? "multiple" : "no", " devices match '$pat'\n";
}
sub xwait {
	my ($pid, $defer) = @_;
	while(waitpid($pid, 0) == -1){ die "waitpid $pid: $!" unless $!{EINTR} }
	$? ? ($? >> 8 or $? | 64) : 0
}
sub ssh_myself {
	use IPC::Open3;
	my ($stdout, $stderr, $ssh_perl, @args) = @_;
	unshift @args, 'verbose=1' if $verbose;
	deb "EXEC @$ssh_perl - @args";
	my $pid = open3 my $to, $_[0], $_[1], @$ssh_perl, '-', @args;
	#print $to our $script or die "print: $!";
	print $to join "\n", q{eval(our $script = <<'__EOT__') or die $@},
			our $script, '__EOT__' or die "print: $!";
	deb "pid=$pid";
	return $pid;
}
sub ssh_myself_simple {
	ssh_myself '>&STDOUT', '>&STDERR', @_;
}
sub copy_output {
	my $o = shift =~ s/^(?=(ERROR:)|(WARNING:)|)/    /r;
	$logger->($1 ? LOG_ERR : $2 ? LOG_WARNING : LOG_DEBUG, $o);
}
sub mk_unix_socket {
	use Socket qw(AF_UNIX SOCK_STREAM SOCK_DGRAM pack_sockaddr_un);
	my ($spec, $path) = @_;
	my $type = $spec =~ /d/ ? SOCK_DGRAM : SOCK_STREAM;
	socket my $sock, AF_UNIX, $type, 0 or die "socket AF_UNIX, $type: $!";
	my $a = pack_sockaddr_un $path;
	if($spec =~ /l/){
		bind $sock, $a or die "bind to $path: $!";
		listen $sock, 12 or die "listen on $path: $!";
	}else{
		connect $sock, $a or die "connect to $path: $!";
	}
	$sock
}
sub get_brackets {
	return unless $_[0] =~ /[[({<]/; my $e = shift =~ y,[({<,])}>,r;
	my @r; push @r, shift while $_[0] ne $e;
}
# my $p = defer sub { ... }; sub will be called when $p goes out of scope
sub defer {
	package defer; sub DESTROY { ${shift()}->() } bless \shift
}
sub local_script {
	my @ssh; @ssh = &get_brackets or @ssh = $SSH;
	while($_[0] =~ /^-/){
		push @ssh, my $o = shift;
		# see getopt(..) in ssh.c
		push @ssh, shift
			if $o =~ /^-[1246afgknqstvxACGKMNPTVXYy]*[bceilmopBDEFIJLOQRSwW]$/;
	}
	my $uhost = shift;
	my @perl; @perl = &get_brackets or @perl = $PERL;
	unless(@_){
		return ssh_myself_simple [@ssh, $uhost, @perl], 'list';
	}elsif($_[0] =~ /^(?:list|find)$/ or $_[0] eq '--' and shift){
		return ssh_myself_simple [@ssh, $uhost, @perl], @_;
	}
	my $tmpdir = xtmpdir;
	my @ssh_S = ($ssh[0], -S => "$tmpdir/ctl", $uhost);
	my $pid = ssh_myself my $sfrom, undef,
		[@ssh, -S => "$tmpdir/ctl", '-M', $uhost, @perl], 'remote', @_;
	my $defer = defer sub { xsystem @ssh_S, qw(-q -O exit) };
	my $response;
	while(<$sfrom>){
		if(/^RESPONSE (.*)/){ $response = $1; last }
		copy_output($_)
	}
	die "remote failure\n" unless $response;
	my ($bus, $dev, $speed, $rpath) = split ' ', $response;
	my $lpath = "$tmpdir/vhci";
	xsystem @ssh_S, qw(-O forward), -L => "$lpath:$rpath";
	my $sock = mk_unix_socket(c => $lpath);
	defined sysread $sock, my $d, 1 or die "sysread on $lpath: $!\n";
	unless($d eq 'T'){
		copy_output($_) while <$sfrom>;
		die "remote failure\n";
	}
	deb sprintf "devspec fd=%d bus/dev=%d/%d (%d) speed=%d",
		$sock->fileno, $bus, $dev, $bus<<16|$dev, $speed;
	local_attach($sock->fileno, $bus, $dev, $speed);
	close $sock;
	xsystem @ssh_S, qw(-q -O stop);
	undef $tmpdir;			# should remove the tmp dir XXX
	copy_output($_) while <$sfrom>;
	$pid, $defer;
}
sub remote_script {
	my ($spec, $opt) = @_;
	my $busid = find_dev($spec);
	my ($bus, $dev, $speed) =
		map xreadfile("$devices/$busid/$_"), qw(busnum devnum speed);
	my $sock;
	{
		my $tmpdir = xtmpdir;
		my $path = "$tmpdir/host";
		my $srv = mk_unix_socket(l => $path);
		deb "listen on $path";
		printf "RESPONSE %d %d %s %s\n", $bus, $dev, $speed, $path;
		open STDOUT, ">/dev/null" or die "open STDOUT>/dev/null: $!";

		vec(my $rb, $srv->fileno, 1) = 1;
		select($rb, undef, undef, .4)
			or die "timeout waiting for connection on $path";
		accept $sock, $srv or die "accept on $path: $!";
		deb "accept on $path";
		remote_attach($sock->fileno, $busid);
		syswrite $sock, 'T', 1 or die "syswrite on $path: $!";
	}

	exit if $opt eq 'nolinger';
	# the only purpose of lingering past this point is to unbind the
	# usbip-host driver from the device after the other side has finished
	# using it

	require IO::Poll; sub POLLRDHUP(){ 0x2000 }
	my $poll = new IO::Poll;
	$poll->mask($sock, POLLRDHUP);

	die "fork: $!" unless defined(my $pid = fork);
	exit if $pid;
	# no point in dying from a SIGPIPE
	use_syslog();
	open STDIN, "</dev/null" or die "open STDIN</dev/null: $!";
	open STDERR, ">/dev/null" or die "open STDERR>/dev/null: $!";
	$poll->poll(-1);
	remote_detach($busid);
}
sub read_uevent { split /[=\n]/, readfile shift }
sub dv { $_[0] =~ s/(\d+)/pack"N",$1/ger }
sub nsort { sort {dv($a) cmp dv($b)} @_ }
sub find {
	my ($d, $pat, $cb) = @_;
	for(do { my $h; opendir $h, $d and readdir $h }){
		next if /^\.\.?$/ or -l (my $s = "$d/$_");
		find($s, $pat, $cb) if -d _;
		$cb->($s) if /\A$pat\z/;
	}
}
sub list_devices {
	opendir my $d, $devices or die "opendir $devices: $!";
	my %c = (
		'01' => 'audio', '02' => 'COM',
		'03' => 'HID',
			'030001' => 'kbd',
			'030002' => 'mouse',
			'030101' => 'kbd',	# boot
			'030102' => 'mouse',	# boot
		'07' => 'printer', '08' => 'UMASS',
		'09' => 'hub', '0a' => 'CDC', '0e' => 'video',
		'e0' => 'wireless',
			'e00101' => 'bluetooth',
			'e00103' => 'RNDIS',
	);
	for(nsort readdir $d){
		my ($dev, $if) = /^(\d+-\d+(?:\.\d+)*)(:[\d.]+)?$/ or next;
		my $path = "$devices/$_";
		my %e = read_uevent "$path/uevent";
		my $indent = $dev =~ y/.// * 2;
		if($if){
			my ($c, $s, $p) = map sprintf('%02x', $_),
				split '/', $e{INTERFACE};
			next if $c eq '09';	# skip hub if
			my (@extra);
			my $ifs = $c{$c.$s.$p} // $c{$c.$s} // $c{$c};
			$ifs = "/$ifs"
				if !$ifs and $ifs = readfile "$path/interface";
			if(my $drv = $e{DRIVER}){
				my @d;
				find $path, 'uevent', sub {
					return unless my %u = read_uevent shift;
					push @d, $u{DEVNAME} =~ s{^input/}{}r
						if exists $u{DEVNAME};
					push @d, ":$u{RFKILL_NAME}"
						if exists $u{RFKILL_NAME};
					push @d, ":$u{INTERFACE}"
						if $u{INTERFACE} =~ m#[^\d/]#;
				};
				push @extra, "[$drv]", nsort @d;
			}
			printf "%*s    %s %s%s%s %-7s %s\n",
				$indent, '', $if, $c, $s, $p, $ifs, join ' ', @extra;
		}else{
			my ($vid, $pid, $rev) = map hex, split '/', $e{PRODUCT};
			my ($serial, $manufacturer, $product) =
				map readfile("$path/$_"),
				qw(serial manufacturer product);
			my $driver = "[$e{DRIVER}]" unless $e{DRIVER} eq 'usb';
			my $extra = join '  ', grep length,
				$serial, $manufacturer, $product, $driver;
			printf "%*s%s  %04x:%04x  %s\n",
				$indent, '', $dev, $vid, $pid, $extra;
		}
	}
}
sub persistent {
	my @args = @_;
	unshift @args, qw(
		-oConnectTimeout=15 -oServerAliveInterval=15
		-oCheckHostIP=no -oBatchMode=yes);
	my ($minwait, $maxwait) = (.5, 60);
	for(my $wait = $minwait;;){
		my $ot = time;
		eval { xwait local_script(@args) };
		$logger->(LOG_ERR, $@) if $@;
		my $dt = time - $ot;
		deb "done after $dt seconds";
		if($dt < $wait){
			my $st = $wait / ($dt > 1 ? $dt : 1);
			deb "will sleep for $st seconds";
			sleep $st;
		}
		if($dt > $maxwait){
			$wait = $minwait;
		}elsif(($wait *= 4) > $maxwait){
			$wait = $maxwait;
		}
	}
}
sub use_syslog {
	my $id = $0 =~ s{.*/}{}r;
	my $sock = mk_unix_socket d => "/dev/log";
	$logger = sub {
		syswrite $sock, sprintf '<%d>%s %s: %s',
			LOG_DAEMON|shift, substr(localtime, 4, 15), $id,
			"@_" =~ s/\s+$//r;
	};
}
sub daemon {
	use POSIX qw(setsid);
	return if my $pid = fork;
	die "fork: $!" unless defined $pid;
	use_syslog();
	die "setsid: $!" unless setsid;
	open *STDIN, '+</dev/null' or die "open /dev/null: $!";
	open $_, '>&', *STDIN or die "open $_ >/dev/null: $!"
		for *STDOUT, *STDERR;
	unshift @_, '-y';	# let ssh use syslog
	persistent(@_);
}
__END__
