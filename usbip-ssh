#! /usr/bin/perl
our $script = sprintf qq{#line %d "%s"\n%s}, __LINE__ + 1, __FILE__, <<'__END__';eval $script; die $@ if $@;
use strict;
my $SSH = 'ssh';
my $PERL = '/usr/bin/perl';
my $drivers = '/sys/bus/usb/drivers';
my $devices = '/sys/bus/usb/devices';
my $verbose;
eval qq{\$$1="\Q$2\E";shift} or die $@ while $ARGV[0] =~ /^(\w+)=(.*)/s;
sub DEBUG {} *DEBUG = sub { print STDERR @_ } if $verbose;
sub ERR { print STDERR @_ }
sub WARN { print STDERR @_ }
$SIG{__DIE__} = sub { ERR "ERROR: @_"; exit 1 unless $^S };
$SIG{__WARN__} = sub { WARN "WARNING: @_" };
my $op = shift;
if($op eq 'remote'){
	remote_script(@ARGV);
}elsif($op eq 'list'){
	list_devices(@ARGV);
}elsif($op eq 'find'){
	print find_dev(@ARGV), "\n";
}elsif($op eq 'unbind'){
	remote_detach(find_dev(@ARGV));
}elsif($op eq 'detach'){
	local_detach(@ARGV);
}elsif($op eq 'keep'){
	persistent(@ARGV);
}elsif($op eq 'daemon'){
	daemon(@ARGV); 
}elsif(length $op){
	exit xwait(local_script($op, @ARGV));
}else{
	my $cmd = $0 =~ s{^.*/}{}r;
	exit print <<"EOT";
usage:
	$cmd USER\@HOST DEV_PATTERN
		attach single device matching DEV_PATTERN from HOST

	$cmd USER\@HOST [list]
		list devices from HOST

	$cmd USER\@HOST find DEV_PATTERN
		find single device matching DEV_PATTERN on HOST

	$cmd keep USER\@HOST ...
		same commands as above, but keep trying to connect to HOST
		and to reconnect to it if the connection is broken

	$cmd daemon USER\@HOST ...
		same as 'keep' but detached from the tty and using syslog
		for messages and errors

	$cmd list
	$cmd find DEV_PATTERN
		same commands as above on the local machine

DEV_PATTERN is as returned by the 'list' command: a busid like 3-3.1, a
vip:pid like 03f0:e111, or a pattern matching the vid:pid, the product name
or the serial number.

You can add command line options for ssh before USER\@HOST.
EOT
}

exit;

###############################################

sub readfile { open my $h, shift or return ""; local $/; <$h> =~ s/\s+$//r }
sub deb { DEBUG "@_\n" }
sub xwritefile {
	my $f = shift;
	deb "WRITE $f < @_";
	open my $h, '>', $f or die "open> $f: $!\n";
	syswrite $h, "@_" or die "write> $f @_: $!\n";
}
sub xreadfile {
	my $f = shift;
	open my $h, '<', $f or die "open< $f: $!\n";
	local $/; my $d = <$h> or die "readline< $f: $!\n";
	$d =~ s/\s+$//;
	die "\nempty file $f" unless length $d;
	deb "READ $f > $d";
	$d;
}
sub xsystem {
	deb "EXEC @_";
	system(@_) == -1 and die "system $_[0]: $!";
	die "system @_: status ".($? >> 8) if $?;
}
sub xtmpdir {
	require File::Temp;
	File::Temp->newdir("usbip-ssh-XXXXXX", TMPDIR => 1);
}

###############################################

use constant {
	LOW => 1, FULL => 2, HIGH => 3, SUPER => 5, SUPER_PLUS => 6,
	SDEV_ST_AVAILABLE => 1, SDEV_ST_USED => 2,
	VDEV_ST_NULL => 4, VDEV_ST_USED => 6,
};
sub remote_attach {
	my ($sockfd, $busid) = @_;
	my $status = readfile "$drivers/usbip-host/$busid/usbip_status";
	if($status != SDEV_ST_AVAILABLE){
		if($status == SDEV_ST_USED){
			xwritefile "$devices/$busid/usbip_sockfd", -1;
		}elsif(readfile("$devices/$busid/bDeviceClass") eq '09'){
			die "$busid is a hub, and usbip-host cannot attach to a hub\n";
		}else{
			xsystem qw(/sbin/modprobe -v usbip-host);
		}
		xwritefile "$drivers/usb/unbind", $busid;
		xwritefile "$drivers/usbip-host/match_busid", "add $busid";
		xwritefile "$drivers/usbip-host/bind", $busid;
	}
	xwritefile "$devices/$busid/usbip_sockfd", $sockfd;
}
sub remote_detach {
	my $busid = shift;
	xwritefile "$drivers/usbip-host/unbind", $busid;
	xwritefile "$drivers/usbip-host/match_busid", "del $busid";
	xwritefile "$drivers/usbip-host/rebind", $busid;
}
sub local_attach {
	my ($sockfd, $bus, $dev, $speed) = @_;
	# as per linux/usb/ch9.h and drivers/usb/core/sysfs.c
	my %hspeed = ( 1.5 => LOW, 12 => FULL, 480 => HIGH,
		5000 => SUPER, 10000 => SUPER_PLUS, 20000 => SUPER_PLUS,
		12 => LOW # override, FULL speed isn't supported
	);
	my $hspeed = $hspeed{$speed} // HIGH;
	xsystem qw(/sbin/modprobe -v vhci-hcd);
	my ($vhci, $port) = find_vhci_and_port($hspeed);
	xwritefile "$vhci/attach",
		sprintf "%d %d %d %d", $port, $sockfd, $bus<<16|$dev, $hspeed;
}
sub local_detach {
	my $busid = join '|', map { /^all$/i ? '.*' : quotemeta } @_;
	my (@b, $n);
	for my $f (</sys/devices/platform/vhci_hcd.*/status*>){
		open my $h, '<', $f or warn "open $f: $!" and next;
		<$h>; # skip header
		while(<$h>){
			my ($hub, $port, $sta, $spd, $dev, $sock_fd, $lbusid)
				= split;
			next unless $sta == VDEV_ST_USED;
			push @b, $lbusid;
			if($lbusid =~ $busid){
				my ($vhci) = $f =~ m{(.*)/};
				xwritefile "$vhci/detach", int($port);
				$n++;
			}
		}
	}
	die "no devices attached\n" unless @b;
	die "'@_' did not match any of: @b\n" unless $n;
}
###############################################
sub find_vhci_and_port {
	my $speed = shift;
	my $shub = $speed >= SUPER ? 'ss' : 'hs';
	for my $f (</sys/devices/platform/vhci_hcd.*/status*>){
		open my $h, '<', $f or warn "open $f: $!" and next;
		<$h>; # skip header
		while(<$h>){
			my ($hub, $port, $sta) = split;
			return $f =~ m{^(.*)/}, int($port)
				if $sta == VDEV_ST_NULL and $hub eq $shub;
		}
	}
	die "no suitable vhci port found for speed = $speed";
}
sub find_dev {
	my ($pat) = @_;
	if($pat =~ /^\d+-\d+(?:\.\d+)*$/){
		return $pat if -d "$devices/$pat";
		die "no such device $pat";
	}
	s/\b0*(?=[0-9a-f]+:)/\\b0*/i, s/:0*([0-9a-f]+)\b/:0*$1\\b/i, $_ = qr/$_/
		for my $rpat = $pat;
	deb "looking for $rpat inside $devices";
	my @found;
	for my $p (<$devices/[0-9]*>){
		next unless my ($busid) = $p =~ m{/(\d+-\d+(?:\.\d+)*)$};
		my ($vid, $pid, $serial, $manufacturer, $product) =
			map readfile("$p/$_"),
			qw(idVendor idProduct serial manufacturer product);
		my $spec = sprintf "%-10s %s:%s  %s  %s  %s",
			$busid, $vid, $pid, $serial, $manufacturer, $product;
		push @found, $busid if my $found = $spec =~ $rpat;
		deb sprintf "  %2s %s", $found && "=>", $spec;
		
	}
	return $found[0] if @found == 1;
	die @found ? "multiple" : "no", " devices match '$rpat'\n";
}
sub xwait {
	waitpid shift // -1, 0; $? ? ($? >> 8 or $? | 64) : 0
}
sub ssh_myself {
	use IPC::Open3;
	my ($stdout, $stderr, $ssh, $uhost, @args) = @_;
	unshift @args, 'verbose=1' if $verbose;
	deb "EXEC @$ssh $uhost $PERL - @args";
	my $pid = open3 my $to, $_[0], $_[1], @$ssh, $uhost, $PERL, '-', @args;
	print $to our $script or die;
	deb "pid=$pid";
	return $pid;
}
sub ssh_myself_simple {
	xwait ssh_myself '>&STDOUT', '>&STDERR', @_;
}
sub copy_output {
	my $i = shift; my $o = "    $i";
	$i =~ /^ERROR:/ ? ERR $o :
	$i =~ /^WARNING:/ ? WARN $o : DEBUG $o;
}
sub local_script {
	my @ssh = $SSH;
	while($_[0] =~ /^-/){
		push @ssh, my $o = shift;
		# see getopt(..) in ssh.c
		push @ssh, shift
			if $o =~ /^-[1246afgknqstvxACGKMNPTVXYy]*[bceilmopBDEFIJLOQRSwW]$/;
	}
	my $uhost = shift;
	unless(@_){
		return ssh_myself_simple [@ssh], $uhost, 'list';
	}elsif($_[0] =~ /^(?:list|unbind|find)$/){
		return ssh_myself_simple [@ssh], $uhost, @_;
	}
	my $tmpdir = xtmpdir;
	my @ssh_S = ($ssh[0], -S => "$tmpdir/ctl", $uhost);
	my $pid = ssh_myself my $sfrom, undef,
		[@ssh, -S => "$tmpdir/ctl", '-M'], $uhost, 'remote', @_;
	my $old_handler = $SIG{__DIE__};
	$SIG{__DIE__} = sub {
		$SIG{__DIE__} = $old_handler;
		use POSIX ':sys_wait_h';
		if(waitpid($pid, WNOHANG) == 0){
			xsystem @ssh_S, qw(-O exit);
			copy_output($_) while <$sfrom>;
			xwait $pid;
		}
		die @_
	};
	my $response;
	while(<$sfrom>){
		if(/^RESPONSE (.*)/){ $response = $1; last }
		else { copy_output($_) }
	}
	die "remote failure\n" unless $response;
	my ($bus, $dev, $speed, $rpath) = split ' ', $response;
	my $lpath = "$tmpdir/vhci";
	xsystem @ssh_S, qw(-O forward), -L => "$lpath:$rpath";
	require IO::Socket::UNIX;
	my $sock = new IO::Socket::UNIX $lpath
		or die "connect to $lpath: $!";
	deb "connect to $lpath";
	defined sysread $sock, my $d, 1 or die "sysread on $lpath: $!\n";
	unless($d eq 'T'){
		copy_output($_) while <$sfrom>;
		die "remote failure\n";
	}
	deb sprintf "devspec fd=%d bus/dev=%d/%d (%d) speed=%d",
		$sock->fileno, $bus, $dev, $bus<<16|$dev, $speed;
	local_attach($sock->fileno, $bus, $dev, $speed);
	close $sock;
	xsystem @ssh_S, qw(-q -O stop);
	undef $tmpdir;			# should remove the tmp dir XXX
	copy_output($_) while <$sfrom>;
	return $pid;
}
sub remote_script {
	my ($spec, $opt) = @_;
	my $busid = find_dev($spec);
	my ($bus, $dev, $speed) =
		map xreadfile("$devices/$busid/$_"), qw(busnum devnum speed);
	my $sock;
	{
		my $tmpdir = xtmpdir;
		my $path = "$tmpdir/host";
		require IO::Socket::UNIX;
		my $srv = new IO::Socket::UNIX(Listen => 1, Local => $path)
			or die "bind to $path: $!";
		deb "listen on $path";
		printf "RESPONSE %d %d %s %s\n", $bus, $dev, $speed, $path;
		open STDOUT, ">/dev/null" or die "open STDOUT>/dev/null: $!";

		vec(my $rb, $srv->fileno, 1) = 1;
		select($rb, undef, undef, .4)
			or die "timeout waiting for connection on $path";
		$sock = $srv->accept or die "accept on $path: $!";
		deb "accept on $path";
		remote_attach($sock->fileno, $busid);
		syswrite $sock, 'T', 1 or die "syswrite on $path: $!";
	}

	exit if $opt eq 'nolinger';
	# the only purpose of lingering past this point is to unbind the
	# usbip-host driver from the device after the other side has finished
	# using it

	require IO::Poll; sub POLLRDHUP(){ 0x2000 }
	my $poll = new IO::Poll;
	$poll->mask($sock, POLLRDHUP);

	die "fork: $!" unless defined(my $pid = fork);
	exit if $pid;
	# no point in dying from a SIGPIPE
	use_syslog();
	open STDIN, "</dev/null" or die "open STDIN</dev/null: $!";
	open STDERR, ">/dev/null" or die "open STDERR>/dev/null: $!";
	$poll->poll(-1);
	remote_detach($busid);
}
sub list_devices {
	opendir my $d, $devices or die "opendir $devices: $!";
	my %c = (
		'01' => 'audio', '02' => 'COM',
		'03' => 'HID',
			'030001' => 'kbd',
			'030002' => 'mouse',
			'030101' => 'kbd',	# boot
			'030102' => 'mouse',	# boot
		'07' => 'printer', '08' => 'UMASS',
		'09' => 'hub', '0a' => 'CDC', '0e' => 'video',
		'e0' => 'wireless',
			'e00101' => 'bluetooth',
			'e00103' => 'RNDIS',
	);
	sub read_uevent { split /[=\n]/, readfile shift }
	sub dv { $_[0] =~ s/(\d+)/pack"N",$1/ger }
	sub nsort { sort {dv($a) cmp dv($b)} @_ }
	for(nsort readdir $d){
		my ($dev, $if) = /^(\d+-\d+(?:\.\d+)*)(:[\d.]+)?$/ or next;
		my $path = "$devices/$_";
		my %e = read_uevent "$path/uevent";
		my $indent = $dev =~ y/.// * 2;
		if($if){
			my ($c, $s, $p) = map sprintf('%02x', $_),
				split '/', $e{INTERFACE};
			next if $c eq '09';	# skip hub if
			my (@extra);
			if(my $ifs = $c{$c.$s.$p} // $c{$c.$s} // $c{$c}){
				push @extra, sprintf "%-7s", $ifs;
			}elsif($ifs = readfile "$path/interface"){
				push @extra, sprintf "/%-6s",
					$ifs =~ s/ Interface$//r;
			}
			if(my $drv = $e{DRIVER}){
				push @extra, "[$drv]";
				my @d;
				use File::Find;
				find { wanted => sub {
					next unless $_ =~ m#/uevent$# and
						my %u = read_uevent $_;
					push @d, $u{DEVNAME} =~ s{^input/}{}r
						if exists $u{DEVNAME};
					push @d, ":$u{RFKILL_NAME}"
						if exists $u{RFKILL_NAME};
					push @d, ":$u{INTERFACE}"
						if $u{INTERFACE} =~ m#[^\d/]#;
				}, no_chdir => 1  }, "$path/";
				push @extra, nsort @d;
			}
			printf "%*s    %s %s%s%s %s\n",
				$indent, '', $if, $c, $s, $p, join ' ', @extra;
		}else{
			my ($vid, $pid, $rev) = map hex, split '/', $e{PRODUCT};
			my ($serial, $manufacturer, $product) =
				map readfile("$path/$_"),
				qw(serial manufacturer product);
			my $driver = "[$e{DRIVER}]" unless $e{DRIVER} eq 'usb';
			my $extra = join '  ', grep length,
				$serial, $manufacturer, $product, $driver;
			printf "%*s%s  %04x:%04x  %s\n",
				$indent, '', $dev, $vid, $pid, $extra;
		}
	}
}
sub persistent {
	my @args = @_;
	unshift @args, qw(
		-oConnectTimeout=15 -oServerAliveInterval=15
		-oCheckHostIP=no -oBatchMode=yes);
	my ($minwait, $maxwait) = (.5, 60);
	for(my $wait = $minwait;;){
		my $ot = time;
		eval { xwait local_script(@args) };
		my $dt = time - $ot;
		deb "done after $dt seconds";
		if($dt < $wait){
			my $st = $wait / ($dt > 1 ? $dt : 1);
			deb "will sleep for $st seconds";
			sleep $st;
		}
		if($dt > $maxwait){
			$wait = $minwait;
		}elsif(($wait *= 4) > $maxwait){
			$wait = $maxwait;
		}
	}
}
sub use_syslog {
	use Sys::Syslog qw(:standard :macros);
	my $syslog = sub {
		openlog $0 =~ s{.*/}{}r, 0, LOG_DAEMON;
		my $prio = shift; syslog $prio, '%s', "@_" =~ s/\n+$//r;
		closelog;
	};
	*ERR = sub { $syslog->(LOG_ERR, @_) };
	*WARN = sub { $syslog->(LOG_WARNING, @_) };
	*DEBUG = sub { $syslog->(LOG_DEBUG, @_) };
}
sub daemon {
	use POSIX qw(setsid);
	return if my $pid = fork;
	die "fork: $!" unless defined $pid;
	use_syslog();
	die "setsid: $!" unless setsid;
	open *STDIN, '+</dev/null' or die "open /dev/null: $!";
	open $_, '>&', *STDIN or die "open $_ >/dev/null: $!"
		for *STDOUT, *STDERR;
	unshift @_, '-y';	# let ssh use syslog
	persistent(@_);
}
__END__
