#! /usr/bin/perl
eval (our $script = sprintf qq{#line %d "%s"\n%s;1}, __LINE__ + 1, __FILE__, <<'__END__') or die $@;
use strict;
my $SSH = 'ssh';
my $PERL = 'perl';
my $SYSFS = '/sys';
my $modprobe = 'modprobe';
my $drivers = "$SYSFS/bus/usb/drivers";
my $devices = "$SYSFS/bus/usb/devices";
my ($verbose);
eval qq{\$$1="\Q$2\E";shift} or die $@ while $ARGV[0] =~ /^(\w+)=(.*)/s;
use constant {
	LOG_WARNING => 4, LOG_ERR => 3, LOG_INFO => 6, LOG_DEBUG => 7,
	LOG_DAEMON => 3<<3,
};
my $logger = sub { shift; print STDERR @_ };
sub DEBUG {} *DEBUG = sub { $logger->(LOG_DEBUG, @_) } if $verbose;
$SIG{__DIE__} = sub { die @_ if $^S; $logger->(LOG_ERR, "ERROR: @_"); exit 1 };
$SIG{__WARN__} = sub { $logger->(LOG_WARNING, "WARNING: @_") };
my $op = shift;
if($op eq 'remote'){
	remote_script(@ARGV);
}elsif($op eq 'list'){
	list_devices(@ARGV);
}elsif($op eq 'find'){
	print find_dev(@ARGV, 1, 1), "\n";
}elsif($op eq 'unbind'){
	remote_detach(find_dev(@ARGV, 1, 1));
}elsif($op eq 'detach'){
	local_detach(@ARGV);
}elsif($op eq 'keep'){
	persistent(@ARGV);
}elsif($op eq 'daemon'){
	daemon(@ARGV); 
}elsif(length $op){
	exit xwait(local_script($op, @ARGV));
}else{
	my $cmd = $0 =~ s{^.*/}{}r;
	print <<"EOT"; exit 1;
usage:
	$cmd USER\@HOST DEV_PATTERN [oneshot] [single]
		attach all the present and future devices matching
		DEV_PATTERN from HOST

		use 'oneshot' to only attach existing devices and die
		if DEV_PATTERN doesn't currently match any of them

		use 'single' to die if DEV_PATTERN matches more than
		one device

	$cmd USER\@HOST [list]
		list devices from HOST

	$cmd USER\@HOST find DEV_PATTERN
		find single device matching DEV_PATTERN on HOST

	$cmd keep USER\@HOST ...
		same commands as above, but keep trying to connect to HOST
		and to reconnect to it if the connection is broken

	$cmd daemon USER\@HOST ...
		same as 'keep' but detached from the tty and using syslog
		for messages and errors

	$cmd list
	$cmd find DEV_PATTERN
		same commands as above on the local machine

DEV_PATTERN is as returned by the 'list' command: a busid like 3-3.1, a
vip:pid like 03f0:e111, or a pattern matching the vid:pid, the product name
or the serial number.

You can add command line options for ssh before USER\@HOST.
EOT
}

###############################################

sub readfile { open my $h, shift or return ""; local $/; <$h> =~ s/\s+$//r }
sub deb { DEBUG "@_\n" }
sub xwritefile {
	my $f = shift;
	open my $h, '>', $f or die "open> $f: $!\n";
	syswrite $h, "@_" or die "write $f < @_: $!\n";
	deb "WRITE $f < @_";
}
sub xreadfile {
	my $f = shift;
	open my $h, '<', $f or die "open< $f: $!\n";
	local $/; my $d = <$h> or die "readline< $f: $!\n";
	$d =~ s/\s+$//;
	die "\nempty file $f" unless length $d;
	deb "READ $f > $d";
	$d;
}
sub xsystem {
	system(@_) == -1 and die "system $_[0]: $!";
	die "system @_: status ".($? >> 8) if $?;
	deb "EXEC @_";
}
sub xtmpdir {
	require File::Temp;
	File::Temp->newdir("usbip-ssh-XXXXXX", TMPDIR => 1);
}

###############################################

use constant {
	LOW => 1, FULL => 2, HIGH => 3, SUPER => 5, SUPER_PLUS => 6,
	SDEV_ST_AVAILABLE => 1, SDEV_ST_USED => 2,
	VDEV_ST_NULL => 4, VDEV_ST_USED => 6,
};
sub remote_attach {
	my ($sockfd, $busid) = @_;
	die "$busid is a hub, and usbip-host cannot attach to a hub\n"
		if readfile("$devices/$busid/bDeviceClass") eq '09';
	my $status = readfile "$drivers/usbip-host/$busid/usbip_status";
	if($status == SDEV_ST_USED){
		xwritefile "$devices/$busid/usbip_sockfd", -1;
	}elsif($status != SDEV_ST_AVAILABLE){
		xsystem $modprobe, 'usbip-host'
			unless -d "$drivers/usbip-host";
		xwritefile "$drivers/usb/unbind", $busid;
		xwritefile "$drivers/usbip-host/match_busid", "add $busid";
		xwritefile "$drivers/usbip-host/bind", $busid;
	}
	xwritefile "$devices/$busid/usbip_sockfd", $sockfd;
}
sub remote_detach {
	my $busid = shift;
	xwritefile "$drivers/usbip-host/unbind", $busid;
	xwritefile "$drivers/usbip-host/match_busid", "del $busid";
	xwritefile "$drivers/usbip-host/rebind", $busid;
}
sub local_attach {
	my ($sockfd, $bus, $dev, $speed) = @_;
	# as per linux/usb/ch9.h and drivers/usb/core/sysfs.c
	my %hspeed = ( 1.5 => LOW, 12 => FULL, 480 => HIGH,
		5000 => SUPER, 10000 => SUPER_PLUS, 20000 => SUPER_PLUS,
	);
	my $hspeed = $hspeed{$speed} // HIGH;
	my ($vhci, $port) = find_vhci_and_port($hspeed);
	xwritefile "$vhci/attach",
		sprintf "%d %d %d %d", $port, $sockfd, $bus<<16|$dev, $hspeed;
}
sub local_detach {
	my (@b, $n, %b); $b{$_} = 1 for @_;
	for my $f (<$SYSFS/devices/platform/vhci_hcd.*/status*>){
		open my $h, '<', $f or warn("open $f: $!"), next;
		<$h>; # skip header
		while(<$h>){
			my ($hub, $port, $sta, $spd, $dev, $sockfd, $busid)
				= split;
			next unless $sta == VDEV_ST_USED;
			push @b, $busid;
			next unless $b{all} or $b{$busid};
			my ($vhci) = $f =~ m{(.*)/};
			xwritefile "$vhci/detach", int($port);
			$n++;
		}
	}
	die "no devices attached\n" unless @b;
	die "'@_' did not match any of: @b\n" unless $n;
}
###############################################
sub find_vhci_and_port {
	my $speed = shift;
	my $shub = $speed >= SUPER ? 'ss' : 'hs';
	xsystem $modprobe, 'vhci-hcd'
		unless <$SYSFS/devices/platform/vhci_hcd.*>;
	for my $f (<$SYSFS/devices/platform/vhci_hcd.*/status*>){
		open my $h, '<', $f or warn "open $f: $!" and next;
		<$h>; # skip header
		while(<$h>){
			my ($hub, $port, $sta) = split;
			return $f =~ m{^(.*)/}, int($port)
				if $sta == VDEV_ST_NULL and $hub eq $shub;
		}
	}
	die "no suitable vhci port found for speed = $speed";
}
sub mk_dev_spec {
	my ($p) = @_;
	my ($vid, $pid, $serial, $manufacturer, $product) =
		map readfile("$p/$_"),
			qw(idVendor idProduct serial manufacturer product);
	sprintf "%-10s %s:%s  %s  %s  %s",
		$p =~ s{.*/}{}r, $vid, $pid, $serial, $manufacturer, $product;
}
sub find_dev {
	my ($pat, $min, $single) = @_;
	if($pat =~ /^\d+-\d+(?:\.\d+)*$/){
		return $pat if -d "$devices/$pat";
		die "no such device $pat";
	}
	for($pat){
		s/\b0*([0-9a-f]+)(?=:)|:\K0*([0-9a-f]+)\b/\\b0*\L$1$2\\b/gi;
		s/\s+/ */g;
		$_ = qr/$_/;
	}
	deb "looking for $pat inside $devices";
	my @found;
	for my $p (<$devices/[0-9]*>){
		next unless my ($busid) = $p =~ m{.*/([0-9.-]+)$};
		my $spec = mk_dev_spec($p);
		push @found, $busid if my $found = $spec =~ $pat;
		deb sprintf "  %2s %s", $found && "=>", $spec;
	}
	if($single){ return $found[0] if @found == 1 }
	else{ return @found if @found >= $min }
	die @found ? "multiple" : "no", " devices match '$pat'\n";
}
sub xwait {
	my ($pid, $defer) = @_;
	while(waitpid($pid, 0) == -1){ die "waitpid $pid: $!" unless $!{EINTR} }
	$? ? ($? >> 8 or $? | 64) : 0
}
sub ssh_myself {
	use IPC::Open3;
	my ($stdout, $stderr, $ssh_perl, @args) = @_;
	unshift @args, 'verbose=1' if $verbose;
	deb "EXEC @$ssh_perl - @args";
	my $pid = open3 my $to, $_[0], $_[1], @$ssh_perl, '-', @args;
	#print $to our $script or die "print: $!";
	print $to join "\n", q{eval(our $script = <<'__EOT__') or die $@},
			our $script, '__EOT__' or die "print: $!";
	deb "pid=$pid";
	return $pid;
}
sub ssh_myself_simple {
	ssh_myself '>&STDOUT', '>&STDERR', @_;
}
sub copy_output {
	my $o = shift =~ s/^(?=(ERROR:)|(WARNING:)|)/    /r;
	$logger->($1 ? LOG_ERR : $2 ? LOG_WARNING : LOG_DEBUG, $o);
}
sub mk_unix_socket {
	use Socket qw(AF_UNIX SOCK_STREAM SOCK_DGRAM pack_sockaddr_un);
	my ($spec, $path) = @_;
	my $type = $spec =~ /d/ ? SOCK_DGRAM : SOCK_STREAM;
	socket my $sock, AF_UNIX, $type, 0 or die "socket AF_UNIX, $type: $!";
	my $a = pack_sockaddr_un $path;
	if($spec =~ /l/){
		bind $sock, $a or die "bind to $path: $!";
		listen $sock, 12 or die "listen on $path: $!";
	}else{
		connect $sock, $a or die "connect to $path: $!";
	}
	$sock
}
sub get_brackets {
	return unless $_[0] =~ /[[({<]/; my $e = shift =~ y,[({<,])}>,r;
	my @r; push @r, shift while $_[0] ne $e;
}
# with 'my $p = defer sub { ... }', 'sub' will be called when '$p' goes
# out of scope
sub defer {
	package defer; sub DESTROY { my $s = shift; $$s->() if $$s }
	bless \shift
}
sub local_script {
	my @ssh; @ssh = &get_brackets or @ssh = $SSH;
	while($_[0] =~ /^-/){
		push @ssh, my $o = shift;
		# see getopt(..) in ssh.c
		push @ssh, shift
			if $o =~ /^-[1246afgknqstvxACGKMNPTVXYy]*[bceilmopBDEFIJLOQRSwW]$/;
	}
	my $uhost = shift;
	my @perl; @perl = &get_brackets or @perl = $PERL;
	unless(@_){
		return ssh_myself_simple [@ssh, $uhost, @perl], 'list';
	}elsif($_[0] =~ /^(?:list|find)$/ or $_[0] eq '--' and shift){
		return ssh_myself_simple [@ssh, $uhost, @perl], @_;
	}
	my $tmpdir = xtmpdir;
	my @ssh_S = ($ssh[0], -S => "$tmpdir/ctl", $uhost);
	my $pid = ssh_myself my $sfrom, undef,
		[@ssh, -S => "$tmpdir/ctl", '-M', $uhost, @perl], 'remote', @_;
	my $defer = defer sub { xsystem @ssh_S, qw(-q -O exit) };
	my $rpath;
	while(<$sfrom>){
		copy_output($_);
		if(/^-Socket (.*)/){ $rpath = $1; last }
	}
	my $lpath = "$tmpdir/vhci";
	deb "listen on $lpath";
	my $lsock = mk_unix_socket(l => $lpath);
	xsystem @ssh_S, qw(-O forward), -R => "$rpath:$lpath";
	xsystem @ssh_S, qw(-q -O stop);
	while(<$sfrom>){
		copy_output($_);
		if(/^-Dev (.*)/){
			my ($bus, $dev, $speed) = split ' ', $1;
			accept my $sock, $lsock or die "accept: $!";
			deb "accept on $lpath = ", $sock->fileno;
			local_attach($sock->fileno, $bus, $dev, $speed);
		}elsif(/^-Done$/){
			last
		}
	}
	$pid, $defer
}
sub mk_uevent_socket {
	use constant {
		AF_NETLINK => 16, SOCK_DGRAM => 2, NETLINK_KOBJECT_UEVENT => 15
	};
	socket my $sock, AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT
		or die "socket(kobject_uevent): $!";
	bind $sock, pack 'Sx[SL]L', AF_NETLINK, 1
		or die "bind(kobject_uevent): $!";
	return $sock;
}
sub daemonize {
	open $_, '>/dev/null' for *STDOUT, *STDERR;
	use_syslog();
	die "fork: $!" unless defined(my $pid = fork);
	exit if $pid;
}
sub remote_script {
	my $pat = shift;
	my %opt; $opt{$_} = 1 for @_;
	open STDIN, '</dev/null';
	$_->autoflush for *STDOUT, *STDERR;
	my $tmpdir = xtmpdir;
	my $rpath = "$tmpdir/host";
	my ($uevent, %sock);
	use IO::Poll qw(POLLIN POLLERR); sub POLLRDHUP(){ 0x2000 }
	my $poll = new IO::Poll;
	my @dev = find_dev($pat, $opt{oneshot}, $opt{single});
	print "-Socket $rpath\n";
	for(my $d = .0001; $d < 2; $d *= 2){
		last if -S $rpath;
		select undef, undef, undef, $d;
	}
	my $new_dev = sub {
		my ($busid, $bus, $dev, $speed) = @_;
		print "-Dev $bus $dev $speed\n";
		my $sock = mk_unix_socket c => $rpath;
		deb "connect to $rpath = ", $sock->fileno;
		remote_attach($sock->fileno, $busid);
		unless($opt{nolinger}){
			$poll->mask($sock, POLLRDHUP);
			$sock{$sock} = $busid;
		}
	};
	for my $busid (@dev){
		my ($bus, $dev, $speed, $class) =
			map xreadfile("$devices/$busid/$_"),
			qw(busnum devnum speed bDeviceClass);
		next if $class eq '09';	# a hub XXX
		$new_dev->($busid, $bus, $dev, $speed);
	};
	if($opt{oneshot}){
		print "-Done\n";
		undef $tmpdir; daemonize();
	}else{
		$poll->mask($uevent = mk_uevent_socket, POLLIN);
		$poll->mask(*STDOUT, POLLERR);	# nb: 0 would remove it
	}
	while($uevent or keys %sock){
		if($poll->poll == -1){
			next if $!{EINTR}; die "poll: $!";
		}
		if($poll->events(*STDOUT) & POLLERR){
			$poll->mask($_, 0) for *STDOUT, $uevent;
			undef $uevent;
			daemonize();
		}
		for($poll->handles(POLLRDHUP)){
			eval { remote_detach(delete $sock{$_}) };
			$logger->(LOG_ERR, $@) if $@;
			$poll->mask($_, 0);
		}
		if($poll->handles(POLLIN)){
			sysread $uevent, my $d, 65536
				or die "sysread(kobject_uevent): $!";
			my ($t, %e) = map split('='), split "\0", $d;
			next unless
				$e{ACTION} eq 'bind' &&
				$e{DEVTYPE} eq 'usb_device' &&
				$e{DRIVER} eq 'usb' &&
				$e{TYPE} ne '9/0/1';	# not a hub
			my $p = "$SYSFS$e{DEVPATH}";
			my $busid = $p =~ s{.*/}{}r;
			my $spec = mk_dev_spec($p);
			deb "UEVENT $spec";
			next unless $spec =~ $pat;
			$new_dev->($busid, $e{BUSNUM}, $e{DEVNUM},
				xreadfile("$p/speed"));
		}
	}
}
sub read_uevent { split /[=\n]/, readfile shift }
sub dv { $_[0] =~ y/:./.:/r =~ s/(\d+)/pack"N",$1/ger }
sub nsort { sort {dv($a) cmp dv($b)} @_ }
sub find {
	my ($d, $pat, $cb) = @_;
	for(do { my $h; opendir $h, $d and readdir $h }){
		next if /^\.\.?$/ or -l (my $s = "$d/$_");
		find($s, $pat, $cb) if -d _;
		$cb->($s) if /\A$pat\z/;
	}
}
sub list_devices {
	opendir my $d, $devices or die "opendir $devices: $!";
	my %c = (
		'01' => 'audio', '02' => 'COM',
		'03' => 'HID',
			'030001' => 'kbd',
			'030002' => 'mouse',
			'030101' => 'kbd',	# boot
			'030102' => 'mouse',	# boot
		'07' => 'printer', '08' => 'UMASS',
		'09' => 'hub', '0a' => 'CDC', '0e' => 'video',
		'e0' => 'wireless',
			'e00101' => 'bluetooth',
			'e00103' => 'RNDIS',
	);
	for(nsort readdir $d){
		my ($dev, $if) = /^([1-9][\d.-]+)(:[\d.]+)?$/ or next;
		my $path = "$devices/$_";
		my %e = read_uevent "$path/uevent";
		my $indent = $dev =~ y/.// * 2;
		if($if){
			my ($c, $s, $p) = map sprintf('%02x', $_),
				split '/', $e{INTERFACE};
			next if $c eq '09';	# skip hub if
			my (@extra);
			my $ifs = $c{$c.$s.$p} // $c{$c.$s} // $c{$c};
			$ifs = "/$ifs"
				if !$ifs and $ifs = readfile "$path/interface";
			if(my $drv = $e{DRIVER}){
				my @d;
				find $path, 'uevent', sub {
					return unless my %u = read_uevent shift;
					push @d, $u{DEVNAME} =~ s{^input/}{}r
						if exists $u{DEVNAME};
					push @d, ":$u{RFKILL_NAME}"
						if exists $u{RFKILL_NAME};
					push @d, ":$u{INTERFACE}"
						if $u{INTERFACE} =~ m#[^\d/]#;
				};
				push @extra, "[$drv]", nsort @d;
			}
			printf "%*s    %s %s%s%s %-7s %s\n",
				$indent, '', $if, $c, $s, $p, $ifs, join ' ', @extra;
		}else{
			printf "%*s%s", $indent, '', mk_dev_spec($path);
			print $e{DRIVER} eq 'usb' ? "\n" : "  [$e{DRIVER}]\n";
		}
	}
}
sub persistent {
	my @args = @_;
	unshift @args, qw(
		-oConnectTimeout=15 -oServerAliveInterval=15
		-oCheckHostIP=no -oBatchMode=yes);
	my ($minwait, $maxwait) = (.5, 60);
	for(my $wait = $minwait;;){
		my $ot = time;
		eval { xwait local_script(@args) };
		$logger->(LOG_ERR, $@) if $@;
		my $dt = time - $ot;
		deb "done after $dt seconds";
		if($dt < $wait){
			my $st = $wait / ($dt > 1 ? $dt : 1);
			deb "will sleep for $st seconds";
			sleep $st;
		}
		if($dt > $maxwait){
			$wait = $minwait;
		}elsif(($wait *= 4) > $maxwait){
			$wait = $maxwait;
		}
	}
}
sub use_syslog {
	my $sock = mk_unix_socket d => "/dev/log";
	$logger = sub {
		syswrite $sock, sprintf '<%d>%s %s: %s',
			LOG_DAEMON|shift, substr(localtime, 4, 15),
			'usbip-ssh', "@_" =~ s/\s+$//r;
	};
}
sub daemon {
	use POSIX qw(setsid);
	return if my $pid = fork;
	die "fork: $!" unless defined $pid;
	use_syslog();
	die "setsid: $!" unless setsid;
	open *STDIN, '+</dev/null' or die "open /dev/null: $!";
	open $_, '>&', *STDIN or die "open $_ >/dev/null: $!"
		for *STDOUT, *STDERR;
	unshift @_, '-y';	# let ssh use syslog
	persistent(@_);
}
__END__
